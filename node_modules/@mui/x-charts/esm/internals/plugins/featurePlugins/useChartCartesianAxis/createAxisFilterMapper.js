import { isDefined } from "../../../isDefined.js";
import { getAxisExtremum } from "./getAxisExtremum.js";
import { getScale } from "../../../getScale.js";
export function createAxisFilterMapper({
  zoomMap,
  zoomOptions,
  seriesConfig,
  formattedSeries,
  direction
}) {
  return (axis, axisIndex) => {
    const zoomOption = zoomOptions[axis.id];
    if (!zoomOption || zoomOption.filterMode !== 'discard') {
      return null;
    }
    const zoom = zoomMap?.get(axis.id);
    if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {
      // No zoom, or zoom with all data visible
      return null;
    }
    const scaleType = axis.scaleType;
    if (scaleType === 'point' || scaleType === 'band') {
      return createDiscreteScaleGetAxisFilter(axis.data, zoom.start, zoom.end, direction);
    }
    return createContinuousScaleGetAxisFilter(scaleType, getAxisExtremum(axis, direction, seriesConfig, axisIndex, formattedSeries), zoom.start, zoom.end, direction, axis.data);
  };
}
export function createDiscreteScaleGetAxisFilter(axisData, zoomStart, zoomEnd, direction) {
  const maxIndex = axisData?.length ?? 0;
  const minVal = Math.floor(zoomStart * maxIndex / 100);
  const maxVal = Math.ceil(zoomEnd * maxIndex / 100);
  return function filterAxis(value, dataIndex) {
    const val = value[direction] ?? axisData?.[dataIndex];
    if (val == null) {
      // If the value does not exist because of missing data point, or out of range index, we just ignore.
      return true;
    }
    return dataIndex >= minVal && dataIndex < maxVal;
  };
}
export function createContinuousScaleGetAxisFilter(scaleType, extrema, zoomStart, zoomEnd, direction, axisData) {
  let min;
  let max;
  [min, max] = getScale(scaleType ?? 'linear', extrema, [0, 100]).nice().domain();
  min = min instanceof Date ? min.getTime() : min;
  max = max instanceof Date ? max.getTime() : max;
  const minVal = min + zoomStart * (max - min) / 100;
  const maxVal = min + zoomEnd * (max - min) / 100;
  return function filterAxis(value, dataIndex) {
    const val = value[direction] ?? axisData?.[dataIndex];
    if (val == null) {
      // If the value does not exist because of missing data point, or out of range index, we just ignore.
      return true;
    }
    return val >= minVal && val <= maxVal;
  };
}
export const createGetAxisFilters = filters => ({
  currentAxisId,
  seriesXAxisId,
  seriesYAxisId,
  isDefaultAxis
}) => {
  return (value, dataIndex) => {
    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;
    if (!axisId || isDefaultAxis) {
      return Object.values(filters ?? {})[0]?.(value, dataIndex) ?? true;
    }
    const data = [seriesYAxisId, seriesXAxisId].filter(id => id !== currentAxisId).map(id => filters[id ?? '']).filter(isDefined);
    return data.every(f => f(value, dataIndex));
  };
};