'use client';

import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { useIsHydrated } from "../hooks/useIsHydrated.js";
import { getStringSize } from "../internals/domUtils.js";
import { useTicks } from "../hooks/useTicks.js";
import { useDrawingArea } from "../hooks/useDrawingArea.js";
import { useChartContext } from "../context/ChartProvider/index.js";
import { shortenLabels } from "./shortenLabels.js";
import { AXIS_LABEL_TICK_LABEL_GAP, TICK_LABEL_GAP, YAxisRoot } from "./utilities.js";
import { useAxisProps } from "./useAxisProps.js";

/**
 * @ignore - internal component.
 */
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
function ChartsSingleYAxis(inProps) {
  const {
    yScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    skipAxisRendering,
    classes,
    Line,
    Tick,
    TickLabel,
    Label,
    axisTickLabelProps,
    axisLabelProps,
    lineProps,
    isRtl
  } = useAxisProps(inProps);
  const {
    position,
    disableLine,
    disableTicks,
    label,
    tickSize: tickSizeProp,
    valueFormatter,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval,
    sx,
    offset,
    width: axisWidth
  } = defaultizedProps;
  const drawingArea = useDrawingArea();
  const {
    left,
    top,
    width,
    height
  } = drawingArea;
  const {
    instance
  } = useChartContext();
  const isHydrated = useIsHydrated();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    direction: 'y'
  });

  // Skip axis rendering if no data is available
  // - The domain is an empty array for band/point scales.
  // - The domains contains Infinity for continuous scales.
  // - The position is set to 'none'.
  if (skipAxisRendering) {
    return null;
  }
  const labelRefPoint = {
    x: positionSign * axisWidth,
    y: top + height / 2
  };
  /* If there's an axis title, the tick labels have less space to render  */
  const tickLabelsMaxWidth = Math.max(0, axisWidth - (label ? getStringSize(label, axisLabelProps.style).height + AXIS_LABEL_TICK_LABEL_GAP : 0) - tickSize - TICK_LABEL_GAP);
  const tickLabels = isHydrated ? shortenLabels(yTicks, drawingArea, tickLabelsMaxWidth, isRtl, axisTickLabelProps.style) : new Map(Array.from(yTicks).map(item => [item, item.formattedValue]));
  return /*#__PURE__*/_jsxs(YAxisRoot, {
    transform: `translate(${position === 'right' ? left + width + offset : left - offset}, 0)`,
    className: classes.root,
    sx: sx,
    children: [!disableLine && /*#__PURE__*/_jsx(Line, _extends({
      y1: top,
      y2: top + height,
      className: classes.line
    }, lineProps)), yTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset,
        value
      } = item;
      const xTickLabel = positionSign * (tickSize + TICK_LABEL_GAP);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === 'function' && !tickLabelInterval?.(value, index);
      const showLabel = instance.isYInside(tickOffset);
      const tickLabel = tickLabels.get(item);
      if (!showLabel) {
        return null;
      }
      return /*#__PURE__*/_jsxs("g", {
        transform: `translate(0, ${tickOffset})`,
        className: classes.tickContainer,
        children: [!disableTicks && /*#__PURE__*/_jsx(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps?.axisTick)), tickLabel !== undefined && !skipLabel && /*#__PURE__*/_jsx(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: tickLabel
        }, axisTickLabelProps))]
      }, index);
    }), label && isHydrated && /*#__PURE__*/_jsx("g", {
      className: classes.label,
      children: /*#__PURE__*/_jsx(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
export { ChartsSingleYAxis };