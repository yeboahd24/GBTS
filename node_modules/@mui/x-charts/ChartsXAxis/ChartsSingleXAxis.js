"use strict";
'use client';

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChartsSingleXAxis = ChartsSingleXAxis;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _useIsHydrated = require("../hooks/useIsHydrated");
var _domUtils = require("../internals/domUtils");
var _useTicks = require("../hooks/useTicks");
var _useMounted = require("../hooks/useMounted");
var _useDrawingArea = require("../hooks/useDrawingArea");
var _useChartContext = require("../context/ChartProvider/useChartContext");
var _shortenLabels = require("./shortenLabels");
var _getVisibleLabels = require("./getVisibleLabels");
var _utilities = require("./utilities");
var _useAxisProps = require("./useAxisProps");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * @ignore - internal component.
 */function ChartsSingleXAxis(inProps) {
  const {
    xScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    skipAxisRendering,
    classes,
    Line,
    Tick,
    TickLabel,
    Label,
    axisTickLabelProps,
    axisLabelProps,
    reverse,
    isRtl
  } = (0, _useAxisProps.useAxisProps)(inProps);
  const isMounted = (0, _useMounted.useMounted)();
  const {
    position,
    disableLine,
    disableTicks,
    label,
    tickSize: tickSizeProp,
    valueFormatter,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement,
    tickLabelMinGap,
    sx,
    offset,
    height: axisHeight
  } = defaultizedProps;
  const drawingArea = (0, _useDrawingArea.useDrawingArea)();
  const {
    left,
    top,
    width,
    height
  } = drawingArea;
  const {
    instance
  } = (0, _useChartContext.useChartContext)();
  const isHydrated = (0, _useIsHydrated.useIsHydrated)();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const xTicks = (0, _useTicks.useTicks)({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement,
    direction: 'x'
  });
  const visibleLabels = (0, _getVisibleLabels.getVisibleLabels)(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    tickLabelMinGap,
    reverse,
    isMounted,
    isXInside: instance.isXInside
  });

  // Skip axis rendering if no data is available
  // - The domain is an empty array for band/point scales.
  // - The domains contains Infinity for continuous scales.
  // - The position is set to 'none'.
  if (skipAxisRendering) {
    return null;
  }
  const labelHeight = label ? (0, _domUtils.getStringSize)(label, axisLabelProps.style).height : 0;
  const labelRefPoint = {
    x: left + width / 2,
    y: positionSign * axisHeight
  };

  /* If there's an axis title, the tick labels have less space to render  */
  const tickLabelsMaxHeight = Math.max(0, axisHeight - (label ? labelHeight + _utilities.AXIS_LABEL_TICK_LABEL_GAP : 0) - tickSize - _utilities.TICK_LABEL_GAP);
  const tickLabels = isHydrated ? (0, _shortenLabels.shortenLabels)(visibleLabels, drawingArea, tickLabelsMaxHeight, isRtl, axisTickLabelProps.style) : new Map(Array.from(visibleLabels).map(item => [item, item.formattedValue]));
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_utilities.XAxisRoot, {
    transform: `translate(0, ${position === 'bottom' ? top + height + offset : top - offset})`,
    className: classes.root,
    sx: sx,
    children: [!disableLine && /*#__PURE__*/(0, _jsxRuntime.jsx)(Line, (0, _extends2.default)({
      x1: left,
      x2: left + width,
      className: classes.line
    }, slotProps?.axisLine)), xTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset
      } = item;
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + _utilities.TICK_LABEL_GAP);
      const showTick = instance.isXInside(tickOffset);
      const tickLabel = tickLabels.get(item);
      const showTickLabel = visibleLabels.has(item);
      return /*#__PURE__*/(0, _jsxRuntime.jsxs)("g", {
        transform: `translate(${tickOffset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && /*#__PURE__*/(0, _jsxRuntime.jsx)(Tick, (0, _extends2.default)({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps?.axisTick)), tickLabel !== undefined && showTickLabel && /*#__PURE__*/(0, _jsxRuntime.jsx)(TickLabel, (0, _extends2.default)({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: tickLabel
        }))]
      }, index);
    }), label && /*#__PURE__*/(0, _jsxRuntime.jsx)("g", {
      className: classes.label,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(Label, (0, _extends2.default)({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}